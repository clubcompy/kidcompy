Todos
=====
- Karma watch for integration tests
- Production build
 * webpack
 * prototype some feature toggles
   * prove they can work (differently) in dev and production builds
   * prove uglifyjs can eliminate feature flag == false dead code blocks in the production builds


Daily Kidcompy developer steps
==============================
1. 'git pull'
2. Add any new ideas you have for features or technical work items to the parking lot so we can discuss and prioritize them
3. Identify work items from Todos that will be worked on today, update or elaborate as needed
4. In a terminal, run 'gulp dev' (or 'gulp integration' if you want to TDD with the integration tests as well)
  * Once Karma starts, capture more browsers for running tests as needed by going to http://localhost:9876/
  * Once the Harness starts, harness more browsers as needed by going to http://localhost:8080/
5. TDD+H:  Red, Green, Refactor, Harness
  * Little 'git commit's as you go, baby steps.
  * The code should always pass tests/bundle successfully or it should be disabled with a feature toggle before commit
  * The harness is a sandbox for the feature you are working on.  Use it to experiment with css styles, scripts and markup
6. At the end of the day or when a work item is complete
  * Tweak feature toggles if necessary, is it time to enable previously dev-only flags in production builds?
  * Spot check that the harness app is still functional
  * 'gulp build' and make sure all lints and tests pass
7. If the status of work items changed, update scratchpad.txt accordingly
8. Do any final commits and 'git push'
9. Update any issue tickets at github or tag releases as needed
10. Repeat or go to bed  ;)


Parking lot or rocket science stuff that is too much research/effort to work on immediately
===========================================================================================
- It would be super sweet to run the javascript through the Google Closure Compiler.  Targeting old browsers means that we could
benefit from Closure Compiler's ability to inline functions and do dead code elimination.  At the cost of a longer loading time, our
usage of libraries like lodash and RxJS could get a real speed boost via the inlining of closures.

I have investigated writing a closure-compiler-loader plugin based on the traceur-loader.  The loader API seems fairly straightforward,
and Webpack could ingest the sourcemap that Closure Compiler emits.  The difficulties with Closure Compiler combined with Webpack are:
  - Closure Compiler does its own CommonJS require-statement dependency injection.  This would mean that the advanced require statement
  support that Webpack supports could not be used, and only static, relative .js file paths could appear in the require statements for
  any javascripts and dependencies that we feed to Closure Compiler.  I imagine the way to deal with this would be to have all of our
  javascripts for a single Webpack chunk to be built using Closure Compiler's CommonJS resolver rather than webpack's.  But I fear this
  won't be good enough since unit tests with karma need to give the units some piecemeal access to individual modules in the bundle.
  - The Closure Compiler command line program has a complex parameter set and is Java which will be non-trivial to rig up from a Webpack
  loader
    - The gulp Closure Compiler plugin has lots of good code to help us build a loader:  https://github.com/steida/gulp-closure-compiler
    - List of available params on Closure Compiler command line:  https://github.com/steida/gulp-closure-compiler/blob/master/flags.txt
  - The Closure Compiler doesn't have the exact same JSDoc dialect as JSDoc3, so there will be a lot of finagling to find syntax that
  works well for jscs-jsdoc and Closure Compiler
  - The Closure Compiler can emit a sourcemap for the compiled output it produces, but it cannot consume and alter a source one.  Does
  this mean that chaining Webpack loaders won't work for javascript compiling unless Closure Compiler is first in the chain (which may not
  be something we want to do)?

I regret not being able to start work on the codebase with the Closure Compiler installed and always on.  Apparently, with the advanced
optimizations turned on, you really want your comprehensive units constantly exercising the optimizations to ensure they don't
unexpectedly start breaking things.  Alas, I think that the Closure Compiler is too far out from the Node.js way of doing things and
therefore will probably not integrate into the Webpack tooling unless some major changes were made to the way that Closure Compiler
works.  Honestly, Closure Compiler feels like it was made by Google, for Google, and therefore it doesn't make sense to expect anything
more from it.

So, realistically it seems like going with UglifyJS2 will be the right course for minification - UglifyJS2 works will with the Node.js/
CommonJS system and has pretty good compression.  Perhaps someday it will even be sophisticated enough to be able to inline functions
like Closure Compiler can.


Annoying things that annoy me
=============================
- On windows, it seems like the ctrl-c handler doesn't allow me to shutdown the web driver for the code harness.  Windows devs will
have to close the harness Firefox instance manually.
