Todos
=====
- Set css class for flipbuffer and playfield so that canvases are clipped and playfields stack
- Paint colored rectangles on Playfield, scroll (by character width), handle wrapping, automatic clearing, etc
  - basic unscrolled rectangle rendering is done.  Add scrolling and render rectangles across canvii boundaries
  - Activate code on the harness and have a fun tech demo
- Start the character generator code, try to render a lower-case 'a'
- After character generator code is in and we have a character printing routine, need to implement scrolling
  - scroll in all directions one character at a time
  - clear rows and columns that scroll onto the screen before scrolling by tagging a space at that spot.
- Write tests for the methods we are using in SystemProperties.js
- The default SystemProperties seem incorrectly set in SystemProperties.js, can the setProperty calls
  in the constructor be moved to modules that would use those particular properties?
? Object.freeze the kidcompy namespace right before onCodeGo triggers
? turn off JSCS on tests completely, (but not JSHint)
- can we get ES6 support going from webpack and closure compiler?

- figure out how to get more verbose logging on failed assertions from karma + proclaim
- Wrap canvases in the playfield in it's own class/objects
- provide utility to get the dom element of the current object (like playfield or flipbuffer or canvases)


Thoughts on Daily Kidcompy developer steps
==========================================
1. 'git pull'
2. Add any new ideas you have for features or technical work items to the parking lot so we can discuss and prioritize
   them
3. Identify work items from Todos that will be worked on today, update or elaborate as needed
4. In a terminal, run 'gulp dev' (or 'gulp integration' if you want to TDD with the integration tests as well)
  * Once Karma starts, capture more browsers for running tests as needed by going to http://localhost:9876/
  * Once the Harness starts, harness more browsers as needed by going to http://localhost:8080/
5. TDD+H:  Red, Green, Refactor, Harness
  * Little 'git commit's as you go, baby steps.
  * The code should always pass tests/bundle successfully or it should be disabled with a feature toggle before commit
  * The harness is a sandbox for the feature you are working on.  Use it to experiment with css styles, scripts and
    markup
6. At the end of the day or when a work item is complete
  * Tweak feature toggles if necessary: is it time to enable previously dev-only flags in the production builds?
  * 'gulp build' and make sure all lints and tests pass
  * Spot check that the harness app is still functional, would be nice if this was never broken
7. If the status of work items changed, update scratchpad.txt accordingly
8. Do any final commits and 'git push'
9. Update any issue tickets at github or tag releases as needed
10. Repeat or go to bed  ;)


Parking lot or rocket science stuff that is too much research/effort to work on immediately
===========================================================================================


Annoying things that annoy me
=============================
- On windows, it seems like the ctrl-c handler doesn't allow me to shutdown the web driver for the code harness.
Windows devs will have to close the harness Firefox instance manually.


Other Thoughts
==============
Doing trunk-based development, having Closure Compiler dead code elimination as part of the build, and using feature
flags to tag builds are all complementary things.


Closure Compiler module styleguide notes
========================================

mutable fields are declared in the constructor as instance variables (attached to the this)
static immutable and mutable fields are attached to the this within the constructor
static functions are attached to the constructor
member functions are attached to the constructor's prototype
only one top-level var statement should appear in a module, and only variables assigned to require statements may be
  listed there in a comma-delimited list.  If you want private/protected static variables in a module, attach them
  to the constructor and mark them @private or @protected as appropriate.
"var self = this;" is allowed in any function with 4 or more statements containing this, or any function that has a
  closure
'this' keyword may not appear in any static functions or at the top-level of a module.
every module must end in "module.exports = ..." and you may assign either the constructor to module.exports, or you
  may immediately construct a singleton to the class and assign that.  Add a @module JSDoc comment for documentation
  purposes for exporting classes, like ...

  /**
   * require("./bootstrap/XHConn2.js") &rArr; {@link XHConn2}
   *
   * @module bootstrap/XHConn2.js
   */
  module.exports = XHConn2;

or, for singleton instances, like ...

  /**
   * require("./bootstrap/main") &rArr; singleton instance of {@link Main}
   *
   * @module bootstrap/main
   */
  module.exports = new Main();

If you are returning a singleton instance, the filename of the module should be a lower-camelCase version of the
class name (so, singleton instance of Main --> main.js).  Otherwise, the filename should exactly match the name of the
class being defined.

There may be odd cases where you want to export a static utility function rather than a Class or a singleton, to do
that, use Object.assign

Use the new keyword to construct object instances, don't hide object construction with constructor tricks.
So as to eliminate circular references, use the closure factory pattern to instantiate closures rather than using
inline anonymous functions.

If you want any static or member fields or functions to be accessible by an unmangled name from the global scope, mark
the symbol @public in the JSDoc and export it using symbols/exportPublicProperties.js.  Public members of your classes
that you will not be exporting to the global scope should NOT be marked @public.  We will use @public to find in files
all of the symbols we plan to export.

----
Seems like Closure Compiler cannot handle calls to static class members from the constructor when those members are
declared after the constructor (by necessity).  This would imply the need for a style guide rule that states that
static class methods may not be invoked from a constructor, and prototype functions should be used instead.

----
Closure Compiler needs CommonJS require statements to declare imported types, even if the types are ONLY referenced
in JSDoc's!  This can get us into conflict with jshint, which warns on unused variables.  Unused variable warnings
from JSHint can be suppressed with // jshint -W098 but it might make more sense to simply disable that feature of
jshint.

----
Inner types and other type nesting seems to be begging for trouble in Closure Compiler, the elisions seem to fire
at odd times there's often funky chicken-or-egg problems that lead to lots of CC undeclared type warnings.  The best
thing to do to make sure we always get good compilations is just make all types top level and live with the module
sprawl that will result.

----
Closure Compiler seems very sensitive to variables being declared AND assigned, receiving an unambiguous
type, in a single statement.  So the following,

  var FlipBuffer;

  /**
   * @constructor
   */
  FlipBuffer = function() {
   ...
  };

will interpret FlipBuffer as 'undefined' by Closure Compiler rather than the constructor function that was declared
because the first value that the FlipBuffer symbol received was undefined since it was not assigned.  The right way
to declare the FlipBuffer constructor would be:

  /**
   * @constructor
   */
  function FlipBuffer() {
  }

This style of declaration implies foisting could become an issue.  We just need to ensure that our symbol names
are clean and foisting won't create any conflicts.

----
Type expressions:
{MyType}   nullable, not optional
{?MyType}  nullable, not optional       (viral when passed from function-to-function?)
{!MyType}  not-nullable, not optional   (viral.  this is my favorite, wished it could be on every parameter)
{MyType=}  optional/undefined
{?MyType=} nullable and optional/undefined
{!MyType=} not-nullable or optional/undefined

If you pass a {?MyType} to a @param {!myType}, you can get very strange and confusing warnings from Closure Compiler.
For example:

  /home/davew/dev/kidcompy/lib/kidcompy/FlipBuffer.js:70: WARNING - actual parameter 1 of Playfield$$module$home$davew$dev$kidcompy$lib$kidcompy$FlipBuffer does not match formal parameter
  found   : (DomMutationsLog$$module$home$davew$dev$kidcompy$lib$kidcompy$FlipBuffer|null)
  required: DomMutationsLog$$module$home$davew$dev$kidcompy$lib$kidcompy$DomMutationsLog

What this is really saying is, the target function wants to see @param {!DomMutationsLog}, but we are trying to pass
in {?DomMutationsLog}.  The chance for nullable is enough to make the {?DomMutationsLog} a one-off type, hence the
parameter type mismatch warning.  This goes to show that ? and ! are viral type markers.  The fix is to either make
all references to DomMutationsLog non-nullable, or do a null check around the call to the target to prove to the
compiler that DomMutationsLog is not nullable in that instance.

----
Module filename conventions:
* Modules that export a constructor function should be named exactly the same as the function which is UpperCamelCased
* Modules that export a javascript singleton object (incl. Enums) containing static members should be UpperCamelCased
  * Mark these objects as @const, no need to Object.freeze() them. This should maximize the members' inlining potential
* Modules that export a utility function should be named exactly the same as the function which is lowerCamelCased
* Modules that do some work (like registering global event handlers) but do not export anything should be
  lowerCamelCased. These modules should be named after their role in the system.

----
Static class members on prototypey classes
* On plain ol' JavaScript objects, static members appear to work well, but only if they are @lends'ed over to the
  constructor function and mixed into the constructor by way of Object.assign()!
* It is dangerous, stupid, and foolish to be placing ANYTHING stateful on a prototypey static member.  You may only
  assign functions constant data as static members on a class.  If you need mutable state global to the kidcompy
  instance, add it to the kidcompy namespace



When do these get done?
=======================

- Start a developer blog
  - Jekyll?  Tumblr?
  - Introduce clubcompy, tell a bit of its history
  - can we point woldie.com at the developer blog?
- Do some initial design work on paper or in the clubcompy wiki that we can use to kick-off proper TDD development
  - Playfield, FlipBuffer, Display?
- Initial development
- Get everything running
- Merge to master, delete develop branch, and do a proper release
  - Branch, build, remove dist line from .gitignore, push, tag, delete branch, back to master?

