Todos
=====
- Create a KidcompyHost class that will be the host for a compy instance.  Hide the constructor and instantiate it via
a static function on the kidcompy namespace.
  - takes a DOM Element that the compy will be displayed out of
  - TBD, don't get undies in bundie
- Object.freeze the kidcompy namespace right before onCodeGo triggers
- turn off JSCS on tests completely, (but not JSHint)
- can we get ES6 support going from webpack and closure compiler?
- DomMutationsLog needs to be consulted in unit tests to verify that the dom is being mutated in the way we expected
  (right now there's a lot of walking up parent nodes, when we have them that I'd like to avoid since there are
  assumptions wrapped up in those assertions.)


Thoughts on Daily Kidcompy developer steps
==========================================
1. 'git pull'
2. Add any new ideas you have for features or technical work items to the parking lot so we can discuss and prioritize
   them
3. Identify work items from Todos that will be worked on today, update or elaborate as needed
4. In a terminal, run 'gulp dev' (or 'gulp integration' if you want to TDD with the integration tests as well)
  * Once Karma starts, capture more browsers for running tests as needed by going to http://localhost:9876/
  * Once the Harness starts, harness more browsers as needed by going to http://localhost:8080/
5. TDD+H:  Red, Green, Refactor, Harness
  * Little 'git commit's as you go, baby steps.
  * The code should always pass tests/bundle successfully or it should be disabled with a feature toggle before commit
  * The harness is a sandbox for the feature you are working on.  Use it to experiment with css styles, scripts and
    markup
6. At the end of the day or when a work item is complete
  * Tweak feature toggles if necessary: is it time to enable previously dev-only flags in the production builds?
  * 'gulp build' and make sure all lints and tests pass
  * Spot check that the harness app is still functional, would be nice if this was never broken
7. If the status of work items changed, update scratchpad.txt accordingly
8. Do any final commits and 'git push'
9. Update any issue tickets at github or tag releases as needed
10. Repeat or go to bed  ;)


Parking lot or rocket science stuff that is too much research/effort to work on immediately
===========================================================================================


Annoying things that annoy me
=============================
- On windows, it seems like the ctrl-c handler doesn't allow me to shutdown the web driver for the code harness.
Windows devs will have to close the harness Firefox instance manually.


Other Thoughts
==============
Doing trunk-based development, having Closure Compiler dead code elimination as part of the build, and using feature
flags to tag builds are all complementary things.


Closure Compiler module styles
==============================

mutable fields are declared in the constructor as instance variables (attached to the this)
static immutable and mutable fields are attached to the constructor
static functions are attached to the constructor
member functions are attached to the constructor's prototype
only one top-level var statement can appear in a module, and only variables assigned to require statements may be
  listed there in a comma-delimited list.  If you want private/protected static variables in a module, attach them
  to the constructor and mark them @private or @protected as appropriate.
"var self = this;" is allowed in any function with 4 or more statements containing this, or any function that has a
  closure
'this' keyword may not appear in any static functions or at the top-level of a module.
every module must end in "module.exports = ..." and you may assign either the constructor to module.exports, or you
  may immediately construct a singleton to the class and assign that.  Add a @module JSDoc comment for documentation
  purposes for exporting classes, like ...

  /**
   * require("./bootstrap/XHConn2.js") &rArr; {@link XHConn2}
   *
   * @module bootstrap/XHConn2.js
   */
  module.exports = XHConn2;

or, for singleton instances, like ...

  /**
   * require("./bootstrap/main") &rArr; singleton instance of {@link Main}
   *
   * @module bootstrap/main
   */
  module.exports = new Main();

If you are returning a singleton instance, the filename of the module should be a lower-camelCase version of the
class name (so, singleton instance of Main --> main.js).  Otherwise, the filename should exactly match the name of the
class being defined.

There may be odd cases where you want to export a static utility function rather than a Class or a singleton, to do
that, use ...

  function extend() { ... }

  /**
   * require("./symbols/extend") &rArr; {@link extend}
   *
   * @module symbols/extend
   */
  module.exports = extend;

Use the new keyword to construct object instances, don't hide object construction with constructor tricks.
So as to eliminate circular references, use the closure factory pattern to instantiate closures rather than using
inline anonymous functions.

If you want any static or member fields or functions to be accessible by an unmangled name from the global scope, mark
the symbol @public in the JSDoc and export it using symbols/exportPublicProperties.js.  Public members of your classes
that you will not be exporting to the global scope should NOT be marked @public.  We will use @public to find in files
all of the symbols we plan to export.


When do these get done?
=======================

- Start a developer blog
  - Jekyll?  Tumblr?
  - Introduce clubcompy, tell a bit of its history
  - can we point woldie.com at the developer blog?
- Do some initial design work on paper or in the clubcompy wiki that we can use to kick-off proper TDD development
  - Playfield, FlipBuffer, Display?
- Initial development
- Get everything running
- Merge to master, delete develop branch, and do a proper release
  - Branch, build, remove dist line from .gitignore, push, tag, delete branch, back to master?

