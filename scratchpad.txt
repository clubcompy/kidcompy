Todos
=====
- Experiment with changing closure compiler's role in the production build.  There is no
way to do a direct integration with webpack. Need to break up the code into four bundles: bootstrap.js, ie8polyfill.js,
html5polyfill.js, and kidcompy.js.  These bundles should have 3 different build types for loading into different
target environments:
  - Development testing mode: no minification. bootstrap.js directly includes ie8polyfill.js, html5polyfill.js, and
    kidcompy.js contents.  Webpack bundling is setup to facilitate straightforward hot-redeploy and CI rather than mimic
    the script separations found in the production builds
  - Production testing mode:  webpack used to bundle bootstrap.js, uglify.js for mangling and minification.  Closure
    compiler or UglifyJS used for ie8polyfill.js, html5polyfill.js.  Closure Compiler used for kidcompy.js CommonJS-mode
    mangling, optimization, and minification.  kidcompy.js will be bundled along with all of its karma unit and
    functional tests.  Karma loads bootstrap.js which then ajaxically loads the remaining scripts as needed.  Karma
    server will be launched directly on bootstrap.js rather than using webpack's karma integration.  bootstrap.js will
    bundle to a standalone script that can execute without a webpack-dev-server to host it
  - Production bundle mode:  webpack used to bundle bootstrap.js, uglify.js for mangling and minification.  Closure
    compiler or UglifyJS used for ie8polyfill.js, html5polyfill.js.  Closure Compiler used for kidcompy.js CommonJS-mode
    mangling, optimization, and minification.  A host page will load bootstrap.js which will then ajaxically load all
    remaining scripts as needed
- Start a developer blog
  - Jekyll?  Tumblr?
  - Introduce clubcompy, tell a bit of its history
  - can we point woldie.com at the developer blog?
- Do some initial design work on paper or in the clubcompy wiki that we can use to kick-off proper TDD development
  - Playfield, FlipBuffer, Display?
- Initial development
- Get everything running
- Merge to master, delete develop branch, and do a proper release
  - Branch, build, remove dist line from .gitignore, push, tag, delete branch, back to master?

Daily Kidcompy developer steps
==============================
1. 'git pull'
2. Add any new ideas you have for features or technical work items to the parking lot so we can discuss and prioritize
   them
3. Identify work items from Todos that will be worked on today, update or elaborate as needed
4. In a terminal, run 'gulp dev' (or 'gulp integration' if you want to TDD with the integration tests as well)
  * Once Karma starts, capture more browsers for running tests as needed by going to http://localhost:9876/
  * Once the Harness starts, harness more browsers as needed by going to http://localhost:8080/
5. TDD+H:  Red, Green, Refactor, Harness
  * Little 'git commit's as you go, baby steps.
  * The code should always pass tests/bundle successfully or it should be disabled with a feature toggle before commit
  * The harness is a sandbox for the feature you are working on.  Use it to experiment with css styles, scripts and
    markup
6. At the end of the day or when a work item is complete
  * Tweak feature toggles if necessary: is it time to enable previously dev-only flags in the production builds?
  * 'gulp build' and make sure all lints and tests pass
  * Spot check that the harness app is still functional, would be nice if this was never broken
7. If the status of work items changed, update scratchpad.txt accordingly
8. Do any final commits and 'git push'
9. Update any issue tickets at github or tag releases as needed
10. Repeat or go to bed  ;)


Parking lot or rocket science stuff that is too much research/effort to work on immediately
===========================================================================================


Annoying things that annoy me
=============================
- On windows, it seems like the ctrl-c handler doesn't allow me to shutdown the web driver for the code harness.
Windows devs will have to close the harness Firefox instance manually.


Other Thoughts
==============
Doing trunk-based development, having Closure Compiler dead code elimination as part of the build, and using feature
flags to tag builds are all complementary things.


Closure Compiler module styles
==============================

mutable fields are declared in the constructor as instance variables (attached to the this)
static immutable and mutable fields are attached to the constructor
static functions are attached to the constructor
member functions are attached to the constructor's prototype
only one top-level var statement can appear in a module, and only variables assigned to require statements may be
  listed there in a comma-delimited list.  If you want private/protected static variables in a module, attach them
  to the constructor and mark them @private or @protected as appropriate.
"var self = this;" is allowed in any function with 4 or more statements containing this, or any function that has a
  closure
'this' keyword may not appear in any static functions or at the top-level of a module.
every module must end in "module.exports = ..." and you may assign either the constructor to module.exports, or you
  may immediately construct a singleton to the class and assign that.  Add a @module JSDoc comment for documentation
  purposes for exporting classes, like ...

  /**
   * require("./bootstrap/XHConn2.js") &rArr; {@link XHConn2}
   *
   * @module bootstrap/XHConn2.js
   */
  module.exports = XHConn2;

or, for singleton instances, like ...

  /**
   * require("./bootstrap/main") &rArr; singleton instance of {@link Main}
   *
   * @module bootstrap/main
   */
  module.exports = new Main();

If you are returning a singleton instance, the filename of the module should be a lower-camelCase version of the
class name (so, singleton instance of Main --> main.js).  Otherwise, the filename should exactly match the name of the
class being defined.

There may be odd cases where you want to export a static utility function rather than a Class or a singleton, to do
that, use ...

  function extend() { ... }

  /**
   * require("./symbols/extend") &rArr; {@link extend}
   *
   * @module symbols/extend
   */
  module.exports = extend;

Use the new keyword to construct object instances, don't hide object construction with constructor tricks.
So as to eliminate circular references, use the closure factory pattern to instantiate closures rather than using
inline anonymous functions.
